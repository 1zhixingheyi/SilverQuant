# SilverQuant 核心模块详解

## 架构概览

### 四层架构

#### 委托层Delegate
- 职责: 封装交易接口
- 抽象: BaseDelegate基类
- 实现: XtDelegate(QMT), GmDelegate(掘金)
- 功能: 下单撤单查询

#### 策略层Trader
- 职责: 交易策略逻辑
- 模块: Buyer买入, Seller卖出, Pools股票池
- 特点: 组件化设计,灵活组合

#### 选股层Selector
- 职责: 筛选买入标的
- 方式: 问财AI, 远程服务, 技术指标
- 输出: 股票代码列表

#### 工具层Tools
- 职责: 基础功能支持
- 包含: 数据缓存, 消息推送, 工具函数

## 委托层详解

### BaseDelegate基类

#### 抽象接口定义
```python
class BaseDelegate:
    # 下单接口
    def order_market_open(code, price, volume, remark, strategy_name)
    def order_market_close(code, price, volume, remark, strategy_name)
    def order_limit_open(code, price, volume, remark, strategy_name)
    def order_limit_close(code, price, volume, remark, strategy_name)

    # 撤单接口
    def order_cancel_all(strategy_name)
    def order_cancel_buy(code, strategy_name)
    def order_cancel_sell(code, strategy_name)

    # 查询接口
    def check_asset() -> Asset
    def check_positions() -> List[Position]
    def check_orders() -> List[Order]
```

#### 设计优势
- 统一接口标准
- 实盘模拟盘无缝切换
- 策略代码完全解耦
- 便于扩展新交易通道

### XtDelegate实盘接口

#### 连接管理
```python
# 初始化连接
def __init__(account_id, client_path, callback, keep_run, ding_messager):
    # 生成session_id
    session_id = int(time.time())

    # 创建XtQuantTrader
    self.xt_trader = XtQuantTrader(client_path, session_id)

    # 注册回调
    self.xt_trader.register_callback(callback)

    # 启动交易线程
    self.xt_trader.start()

    # 建立连接
    connect_result = self.xt_trader.connect()

    # 订阅主推
    subscribe_result = self.xt_trader.subscribe(account)

    # 开启保活线程
    if keep_run:
        Thread(target=self.keep_connected).start()
```

#### 保活机制
```python
def keep_connected(self):
    while True:
        time.sleep(60)  # 每60秒检测一次
        self.reconnect()

def reconnect(self):
    if self.xt_trader is None:
        self.connect(self.callback)
```

#### 市价单处理
```python
def order_market_open(code, price, volume, remark, strategy_name):
    # 深圳市价单
    if get_code_exchange(code) == 'SZ':
        price_type = MARKET_SZ_CONVERT_5_CANCEL  # 五档即成转限价
        price_submit = -1  # 深市不需要价格

    # 上海市价单
    elif get_code_exchange(code) == 'SH':
        price_type = MARKET_PEER_PRICE_FIRST  # 对手方最优
        price_submit = price  # 沪市需要价格

    # 提交委托
    self.order_submit(code, STOCK_BUY, volume, price_type, price_submit, ...)

    # 钉钉通知
    if self.ding_messager:
        self.ding_messager.send_text_as_md(f'市买 {code} {volume}股 {price:.2f}元')
```

#### 限价单处理
```python
def order_limit_open(code, price, volume, remark, strategy_name):
    # 固定价格委托
    self.order_submit(
        stock_code=code,
        order_type=STOCK_BUY,
        order_volume=volume,
        price_type=FIX_PRICE,  # 限价单
        price=price,
        strategy_name=strategy_name,
        order_remark=remark,
    )
```

#### 涨跌停保护
```python
# 买入时涨停保护
order_price = price + self.order_premium
limit_price = get_limit_up_price(code, last_close)

if order_price > limit_price:
    # 涨停了只能挂限价单
    delegate.order_limit_open(code, limit_price, volume, remark)
else:
    # 正常市价单
    delegate.order_market_open(code, order_price, volume, remark)

# 卖出时跌停保护
order_price = quote['lastPrice'] - self.order_premium
limit_price = get_limit_down_price(code, quote['lastClose'])

if order_price < limit_price:
    # 跌停了只能挂限价单
    delegate.order_limit_close(code, limit_price, volume, remark)
else:
    # 正常市价单
    delegate.order_market_close(code, order_price, volume, remark)
```

### GmDelegate模拟盘接口

#### 账户登录
```python
def __init__(account_id, callback, ding_messager):
    # 设置服务器
    set_endpoint('api.myquant.cn:9000')

    # 设置Token
    set_token(GM_CLIENT_TOKEN)

    # 登录账户
    self.account = account(account_id=GM_ACCOUNT_ID, account_alias='')
    login(self.account)

    # 注册回调
    if callback:
        callback.register_callback()
```

#### 数据转换封装
```python
# 掘金资产 → 标准资产
class GmAsset:
    def __init__(self, cash: Cash):
        self.cash = round(cash.available, 3)
        self.frozen_cash = round(cash.order_frozen, 3)
        self.market_value = round(cash.frozen, 3)
        self.total_asset = round(cash.nav, 3)

# 掘金持仓 → 标准持仓
class GmPosition:
    def __init__(self, position: Position):
        self.stock_code = gmsymbol_to_code(position.symbol)
        self.volume = position.volume
        self.can_use_volume = position.available
        self.open_price = position.vwap
```

### 回调系统

#### 委托回调
```python
class XtCustomCallback:
    def on_order_stock_async_response(self, order):
        # 委托响应
        logging.info(f'委托响应: {order.stock_code} {order.order_volume}股')

    def on_order_error(self, order_error):
        # 委托错误
        logging.error(f'委托失败: {order_error.error_msg}')
        if self.ding_messager:
            self.ding_messager.send_text(f'⚠️ {order_error.error_msg}')
```

#### 成交回调
```python
def on_stock_trade(self, trade):
    # 记录成交
    self.record_order(
        order_time=time.time(),
        code=trade.stock_code,
        price=trade.traded_price,
        volume=trade.traded_volume,
        side='成交',
        remark=trade.order_remark
    )

    # 更新持仓天数(买入)
    if trade.order_type == STOCK_BUY:
        self.update_held_days(trade.stock_code, 0)

    # 清理持仓记录(卖出)
    elif trade.order_type == STOCK_SELL:
        self.clear_position_cache(trade.stock_code)
```

## 策略层详解

### Buyer买入模块

#### 风险控制逻辑
```python
class BaseBuyer:
    def order_buy(code, price, last_close, volume, remark, market=True):
        buy_volume = volume

        # 风控: 单票资金上限
        if self.risk_control:
            max_volume = math.floor(self.slot_capacity / price / 100) * 100
            if buy_volume > max_volume:
                buy_volume = max_volume
                logging.warning(f'{code} 超过风控,调整为 {buy_volume}股')

        # 溢价保护
        order_price = price + self.order_premium
        limit_price = get_limit_up_price(code, last_close)

        # 涨停判断
        if market:
            if order_price > limit_price:
                # 涨停挂限价
                delegate.order_limit_open(code, limit_price, buy_volume, remark)
            else:
                # 正常市价
                delegate.order_market_open(code, order_price, buy_volume, remark)
```

#### 分批买入
```python
class LimitedBuyer(BaseBuyer):
    def __init__(volume_ratio=1.00):
        # volume_ratio: 买入比例 0.5=半仓, 1.0=满仓
        self.volume_ratio = volume_ratio

    def order_buy(code, price, volume, ...):
        # 按比例调整数量
        volume = math.floor(volume / 100 * self.volume_ratio) * 100
        super().order_buy(code, price, volume, ...)
```

### Seller卖出模块

#### 卖出流程
```python
class BaseSeller:
    def execute_sell(quotes, curr_date, curr_time, positions, held_days, max_prices, cache_history):
        # 遍历所有持仓
        for position in positions:
            code = position.stock_code

            # 必要数据检查
            if (code in quotes) and (code in held_days):
                quote = quotes[code]

                # 停牌检查
                if quote['open'] > 0 and quote['volume'] > 0:
                    # 调用卖出判断
                    self.check_sell(
                        code=code,
                        quote=quote,
                        curr_date=curr_date,
                        curr_time=curr_time,
                        position=position,
                        held_day=held_days[code],
                        max_price=max_prices.get(code),
                        history=cache_history.get(code),
                        ticks=today_ticks.get(code),
                        extra=extra_datas.get(code),
                    )
```

#### 卖出策略接口
```python
def check_sell(code, quote, curr_date, curr_time, position, held_day, max_price, history, ticks, extra) -> bool:
    """
    返回True表示已卖出,阻止后续策略
    返回False表示未卖出,继续判断下一个策略
    """
    # 具体卖出逻辑
    if 满足卖出条件:
        self.order_sell(code, quote, volume, remark)
        return True  # 卖了就不再判断
    return False  # 没卖继续判断
```

### 卖出策略组件

#### HardSeller硬性止损止盈
```python
class HardSeller(BaseSeller):
    def __init__(parameters):
        self.hard_time_range = ['09:31', '14:57']  # 时间范围
        self.earn_limit = 1.15    # 15%止盈
        self.risk_limit = 0.97    # 3%止损
        self.risk_tight = 0.002   # 止损每日上移0.2%

    def check_sell(code, quote, curr_time, position, held_day, ...):
        # 时间检查
        if self.hard_time_range[0] <= curr_time < self.hard_time_range[1]:
            curr_price = quote['lastPrice']
            cost_price = position.open_price

            # 动态止损线 = 成本价 * (止损率 + 持仓天数 * 日递增)
            switch_lower = cost_price * (self.risk_limit + held_day * self.risk_tight)

            # 止损判断
            if curr_price <= switch_lower:
                self.order_sell(code, quote, volume, f'跌3%硬止损')
                return True

            # 止盈判断
            elif curr_price >= cost_price * self.earn_limit:
                self.order_sell(code, quote, volume, f'涨15%硬止盈')
                return True

        return False
```

#### FallSeller回落止盈
```python
class FallSeller(BaseSeller):
    def __init__(parameters):
        # 分级回落配置: (涨幅下限, 涨幅上限, 回落幅度)
        self.fall_from_top = [
            (1.08, 9.99, 0.02),  # 涨8%以上, 回落2%卖
            (1.02, 1.08, 0.05),  # 涨2-8%, 回落5%卖
        ]

    def check_sell(code, quote, position, max_price, ...):
        if max_price is not None:
            curr_price = quote['lastPrice']
            cost_price = position.open_price

            # 遍历分级配置
            for inc_min, inc_max, fall_threshold in self.fall_from_top:
                # 判断涨幅区间
                if cost_price * inc_min <= max_price < cost_price * inc_max:
                    # 判断回落幅度
                    if curr_price < max_price * (1 - fall_threshold):
                        self.order_sell(code, quote, volume,
                                       f'涨{int((inc_min-1)*100)}%回落{int(fall_threshold*100)}%')
                        return True
        return False
```

#### ReturnSeller回撤止盈
```python
class ReturnSeller(BaseSeller):
    def __init__(parameters):
        # 分级回撤配置: (涨幅下限, 涨幅上限, 利润回撤比例)
        self.return_of_profit = [
            (1.20, 9.99, 0.10),  # 涨20%以上, 利润回撤10%卖
            (1.08, 1.20, 0.20),  # 涨8-20%, 利润回撤20%卖
            (1.05, 1.08, 0.30),  # 涨5-8%, 利润回撤30%卖
            (1.03, 1.05, 0.50),  # 涨3-5%, 利润回撤50%卖
            (1.02, 1.03, 0.80),  # 涨2-3%, 利润回撤80%卖
        ]

    def check_sell(code, quote, position, max_price, ...):
        if max_price is not None:
            curr_price = quote['lastPrice']
            cost_price = position.open_price
            profit = max_price - cost_price  # 最大利润

            for inc_min, inc_max, fall_percentage in self.return_of_profit:
                if cost_price * inc_min <= max_price < cost_price * inc_max:
                    # 当前价 < 最高价 - 利润回撤
                    if curr_price < max_price - profit * fall_percentage:
                        self.order_sell(code, quote, volume,
                                       f'涨{int((inc_min-1)*100)}%回撤{int(fall_percentage*100)}%')
                        return True
        return False
```

#### SwitchSeller换仓止损
```python
class SwitchSeller(BaseSeller):
    def __init__(parameters):
        self.switch_hold_days = 3              # 持仓天数要求
        self.switch_demand_daily_up = 0.003    # 日均收益要求0.3%
        self.switch_time_range = ['14:30', '14:57']  # 尾盘时段

    def check_sell(code, quote, curr_time, position, held_day, ...):
        # 持仓天数要求
        if held_day >= self.switch_hold_days:
            # 尾盘时段
            if self.switch_time_range[0] <= curr_time < self.switch_time_range[1]:
                curr_price = quote['lastPrice']
                cost_price = position.open_price

                # 目标收益 = 成本价 * (1 + 持仓天数 * 日均要求)
                switch_upper = cost_price * (1 + held_day * self.switch_demand_daily_up)

                # 未达目标换仓
                if curr_price < switch_upper:
                    self.order_sell(code, quote, volume, f'{self.switch_hold_days}日换仓')
                    return True
        return False
```

#### MASeller均线止损
```python
class MASeller(BaseSeller):
    def __init__(parameters):
        self.ma_time_range = ['09:31', '14:57']
        self.ma_above = 5  # 5日均线

    def check_sell(code, quote, curr_time, position, history, ...):
        if history is not None:
            curr_price = quote['lastPrice']

            # 计算N日均线
            if len(history) >= self.ma_above:
                ma_n = history['close'].tail(self.ma_above).mean()

                # 跌破均线卖出
                if curr_price < ma_n:
                    self.order_sell(code, quote, volume, f'破{self.ma_above}日均线')
                    return True
        return False
```

#### UppingBlocker上涨阻断器
```python
class UppingBlocker(BaseSeller):
    def check_sell(code, quote, curr_time, position, history, ...):
        # 不是真正的Seller, 而是阻断器
        if history is not None and len(history) >= 30:
            # 判断日内均价是否上涨
            curr_price = quote['lastPrice']
            avg_price = (quote['amount'] / quote['volume']) if quote['volume'] > 0 else curr_price
            is_avg_up = avg_price > history['close'].values[-1]

            # 判断MACD是否上升
            macd_df = MACD(history['close'])
            is_macd_up = macd_df['MACD'].values[-1] > macd_df['MACD'].values[-2]

            # 双涨趋势 → 阻断卖出
            if is_avg_up and is_macd_up:
                return True  # 返回True阻断后续Seller

        return False  # 不阻断
```

### 策略组合GroupSeller

#### 组合原理
```python
class GroupSellers:
    def group_check_sell(self, code, quote, ...):
        sold = False

        # 按继承顺序依次执行
        for parent in self.__class__.__bases__:
            if parent.__name__ != 'GroupSellers':
                if sold:
                    break  # 已卖出则停止
                else:
                    sold = parent.check_sell(self, code, quote, ...)

        return sold
```

#### 经典组合
```python
class ClassicGroupSeller(GroupSellers, HardSeller, FallSeller, ReturnSeller):
    """
    执行顺序:
    1. HardSeller - 硬性止损止盈(优先级最高)
    2. FallSeller - 回落止盈
    3. ReturnSeller - 回撤止盈
    """
    def __init__(self, strategy_name, delegate, parameters):
        super().__init__()
        self.group_init(strategy_name, delegate, parameters)
```

#### 均线组合
```python
class ClassicMAGroupSeller(GroupSellers, HardSeller, FallSeller, ReturnSeller, MASeller):
    """
    执行顺序:
    1. HardSeller - 硬性止损
    2. FallSeller - 回落止盈
    3. ReturnSeller - 回撤止盈
    4. MASeller - 均线止损
    """
```

#### 平台绿缩组合
```python
class PTLSGroupSeller(GroupSellers, HardSeller, UppingBlocker, FallSeller, ReturnSeller, SwitchSeller, MASeller):
    """
    执行顺序:
    1. HardSeller - 硬性止损(第一道防线)
    2. UppingBlocker - 上涨阻断(阻止后续卖出)
    3. FallSeller - 回落止盈
    4. ReturnSeller - 回撤止盈
    5. SwitchSeller - 换仓卖出
    6. MASeller - 均线止损(最后防线)

    特点: 六层保护, 适合趋势票
    """
```

### 股票池管理

#### 白名单类型

##### 指数成分股
```python
class StocksPoolWhiteIndexes(StockPool):
    def __init__(parameters):
        self.white_indexes = parameters.white_indexes

    def refresh_white(self):
        for index_code in self.white_indexes:
            # 获取成分股
            codes = get_index_constituent_codes(index_code)
            self.cache_whitelist.update(codes)

# 使用示例
class PoolConf:
    white_indexes = [
        IndexSymbol.INDEX_ZZ_500,   # 中证500
        IndexSymbol.INDEX_ZZ_1000,  # 中证1000
    ]
```

##### 行业板块
```python
class StocksPoolWhiteIndustry(StockPool):
    def __init__(parameters):
        self.white_industry = parameters.white_industry

    def refresh_white(self):
        for industry_name in self.white_industry:
            # 获取行业股票
            codes = get_dfcf_industry_stock_codes(industry_name)
            self.cache_whitelist.update(codes)

# 使用示例
class PoolConf:
    white_industry = ['半导体', '新能源汽车', '人工智能']
```

#### 黑名单过滤
```python
class StocksPoolBlackWencai(StockPool):
    def __init__(parameters):
        self.black_prompts = parameters.black_prompts

    def refresh_black(self):
        # 问财筛选黑名单
        codes = get_wencai_codes(self.black_prompts)
        self.cache_blacklist.update(codes)

# 使用示例
class PoolConf:
    black_prompts = ['ST', '退市', '*ST', '停牌']
```

#### 技术指标预筛
```python
def filter_white_list_by_selector(self, filter_func, cache_history):
    remove_list = []

    for code in self.cache_whitelist:
        if code in cache_history:
            try:
                # 应用筛选函数
                df = filter_func(cache_history[code], code, None)

                # 最后一行PASS字段为False则剔除
                if (len(df) > 0) and (not df['PASS'].values[-1]):
                    remove_list.append(code)
            except Exception as e:
                remove_list.append(code)
        else:
            # 没有历史数据也剔除
            remove_list.append(code)

    # 从白名单移除
    for code in remove_list:
        self.cache_whitelist.discard(code)

# 使用示例: MACD金叉筛选
def macd_filter(df, code, quote):
    macd_df = MACD(df['close'])
    df['PASS'] = macd_df['MACD'] > macd_df['SIGNAL']
    return df
```

## 订阅调度系统

### XtSubscriber核心流程

#### 初始化
```python
class XtSubscriber:
    def __init__(
        account_id,
        strategy_name,
        delegate,
        execute_strategy,      # 策略回调函数
        execute_interval=1,    # 执行间隔秒
        before_trade_day=None, # 盘前函数
        finish_trade_day=None, # 盘后函数
    ):
        self.execute_strategy = execute_strategy
        self.cache_quotes = {}      # 实时行情缓存
        self.cache_history = {}     # 历史数据缓存
        self.code_list = []         # 订阅代码列表
```

#### 行情订阅回调
```python
def callback_sub_whole(self, quotes: Dict):
    now = datetime.datetime.now()
    curr_date = now.strftime('%Y-%m-%d')
    curr_time = now.strftime('%H:%M')
    curr_seconds = now.strftime('%S')

    # 更新行情缓存
    with self.lock_quotes_update:
        self.cache_quotes.update(quotes)

    # 每秒执行策略
    if self.cache_limits['prev_seconds'] != curr_seconds:
        self.cache_limits['prev_seconds'] = curr_seconds

        if int(curr_seconds) % self.execute_interval == 0:
            # 调用策略
            self.execute_strategy(
                curr_date,
                curr_time,
                curr_seconds,
                self.cache_quotes,
            )
```

#### 定时任务调度
```python
def start_scheduler(self):
    if self.use_ap_scheduler:
        # 使用APScheduler
        from apscheduler.schedulers.blocking import BlockingScheduler
        scheduler = BlockingScheduler()

        # 盘前任务
        scheduler.add_job(
            self.before_trade_day,
            'cron',
            day_of_week='mon-fri',
            hour=8,
            minute=50
        )

        # 盘中行情订阅
        scheduler.add_job(
            self.subscribe_quotes,
            'cron',
            day_of_week='mon-fri',
            hour='9-15',
            minute='*',
            second='*/1'
        )

        # 盘后任务
        scheduler.add_job(
            self.finish_trade_day,
            'cron',
            day_of_week='mon-fri',
            hour=15,
            minute=10
        )

        scheduler.start()
```

### 策略执行框架
```python
def execute_strategy(curr_date, curr_time, curr_seconds, curr_quotes):
    # 查询持仓
    positions = my_delegate.check_positions()

    # 卖点扫描
    for time_range in SellConf.time_ranges:
        if time_range[0] <= curr_time <= time_range[1]:
            if int(curr_seconds) % SellConf.interval == 0:
                scan_sell(curr_quotes, curr_date, curr_time, positions)

    # 买点扫描
    for time_range in BuyConf.time_ranges:
        if time_range[0] <= curr_time <= time_range[1]:
            if int(curr_seconds) % BuyConf.interval == 0:
                scan_buy(curr_quotes, curr_date, positions)
                return True

    return False
```

## 数据缓存系统

### 持仓数据缓存

#### held_days.json持仓天数
```json
{
  "000001.SZ": 3,
  "000002.SZ": 1,
  "600000.SH": 5
}
```

#### max_price.json历史最高价
```json
{
  "000001.SZ": 12.56,
  "000002.SZ": 15.78,
  "600000.SH": 8.90
}
```

#### min_price.json历史最低价
```json
{
  "000001.SZ": 11.23,
  "000002.SZ": 14.56,
  "600000.SH": 8.12
}
```

### 交易数据缓存

#### deal_hist.csv交易历史
```csv
时间,代码,名称,价格,数量,方向,备注
2025-01-15 09:35:23,000001.SZ,平安银行,12.34,1000,买入委托,问财选股
2025-01-15 09:35:25,000001.SZ,平安银行,12.35,1000,成交,买入
2025-01-15 14:32:10,000001.SZ,平安银行,12.78,1000,卖出委托,涨3%硬止盈
2025-01-15 14:32:12,000001.SZ,平安银行,12.77,1000,成交,卖出
```

#### assets.csv资金曲线
```csv
日期,总资产,可用资金,持仓市值,当日盈亏,累计盈亏
2025-01-15,102345.67,50000.00,52345.67,345.67,2345.67
2025-01-16,103456.78,55000.00,48456.78,1111.11,3456.78
```

### 缓存操作函数

#### 读写JSON
```python
def load_json(path, disk_lock):
    with disk_lock:
        if os.path.exists(path):
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
    return {}

def save_json(path, data, disk_lock):
    with disk_lock:
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
```

#### 更新最高价
```python
def update_max_prices(disk_lock, quotes, positions, path_max, path_min, path_held):
    max_prices = load_json(path_max, disk_lock)
    held_days = load_json(path_held, disk_lock)

    for position in positions:
        code = position.stock_code
        if code in quotes:
            curr_price = quotes[code]['lastPrice']

            # 更新历史最高价
            if code not in max_prices:
                max_prices[code] = curr_price
            else:
                max_prices[code] = max(max_prices[code], curr_price)

    save_json(path_max, max_prices, disk_lock)
    return max_prices, held_days
```

## 技术指标库MyTT

### 内置指标

#### MACD指标
```python
from mytt.MyTT_advance import MACD

# 计算MACD
df_macd = MACD(close_series, SHORT=12, LONG=26, M=9)
# 返回: DIFF, DEA, MACD

# 金叉判断
is_golden_cross = (df_macd['DIFF'].values[-1] > df_macd['DEA'].values[-1]) and \
                  (df_macd['DIFF'].values[-2] <= df_macd['DEA'].values[-2])
```

#### KDJ指标
```python
from mytt.MyTT_advance import KDJ

df_kdj = KDJ(close_series, high_series, low_series, N=9, M1=3, M2=3)
# 返回: K, D, J

# 超卖判断
is_oversold = df_kdj['J'].values[-1] < 20
```

#### CCI指标
```python
from mytt.MyTT_advance import CCI

df_cci = CCI(close_series, high_series, low_series, N=14)
# 返回: CCI

# 超买超卖
is_overbought = df_cci['CCI'].values[-1] > 100
is_oversold = df_cci['CCI'].values[-1] < -100
```

### 自定义指标
```python
from mytt.MyTT import *

def custom_indicator(df):
    close = df['close']
    high = df['high']
    low = df['low']

    # 使用MyTT函数
    ma5 = MA(close, 5)
    ma10 = MA(close, 10)

    # 自定义逻辑
    df['MA5'] = ma5
    df['MA10'] = ma10
    df['SIGNAL'] = ma5 > ma10  # 短期均线>长期均线

    return df
```

## 总结

### 模块协作流程
```
1. XtSubscriber订阅行情
2. 行情更新触发callback_sub_whole
3. 定时调用execute_strategy
4. execute_strategy调用scan_sell/scan_buy
5. Buyer/Seller执行交易逻辑
6. Delegate执行委托下单
7. Callback记录成交回报
8. 更新缓存数据
```

### 扩展开发要点
- 新Seller继承BaseSeller
- 新Buyer继承BaseBuyer
- 新Pool继承StockPool
- 新Delegate继承BaseDelegate
- 注意线程锁disk_lock
- 缓存数据及时持久化